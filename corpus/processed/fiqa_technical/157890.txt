"I recently needed to compute a better balance that let us pick and choose what to include in the computed sum without losing information, so I revisited this topic and I'm pleased to say that I've found a solution that works (at least for our data - you may have transactions that this code doesn't recognize, but you can always modify it to match). My solution was written natively for MS SQL Server 2008 or later, it uses a scalar UDF, a VIEW, and a windowed aggregate (SUM OVER (ORDER BY ..) which means it should be almost-syntax compatible with PostgreSQL. MySQL does not support OVER but you can perform a running-sum using a variable with arithmetic addition directly in the SELECT clause. Create a database table with this schema (feel free to exclude columns you're not interested in, such as Option1Name): Create a UNIQUE index on TxnId - you could use it as a primary-key, I suppose. You might be tempted to create a Foreign-Key relationship between ReferenceTxnId and TxnId, however this will fail if you enforce it: we have many transactions where ReferenceTxnId points to a Transaction that doesn't exist. This is usually in the case of [Type] = 'Web Accept Payment Received' AND [Status] = 'Canceled'. We also have some TransactionId values longer than 17 characters: some TransactionIds start with ""U-"" - all pending money requests, I suspect this indicates the transaction is ""unfinished"". Re-download your entire PayPal History CSV files so that you have the latest retroactive updates. Import these CSV files into this PayPalHistory table. Do a simple test to see how bad PayPal's default data is: To find out where the differences are coming from, run this query: (The ORDER BY (..), RowId is to ensure consistent ordering when multiple transactions share the same timestamp) As you scroll through the results, you'll see how the naive SUM is thrown-off from the official PayPal-computed Balance column. So as you can see, the Net column value cannot always be trusted - what we need is to generate our own ""EffectiveNet"" value which is accurate - that is, the value is 0.00 for rows which do not affect the balance, instead of being what they are right now. The problem is, given a single row of data (such as any single row from the example table in my original Question) we have no way of inherently knowing what its ""EffectiveNet"" is. I have devised two functions to help solve this problem, the first function only looks at the ReferenceTxnId, Type and Status column values and generates accurate values for the vast majority of rows - indeed, in our dataset we only had one row for which this approach did not work. I recommend you try this one first and compare the running-sum value to ensure it works for your data: You can use this function in the query like so below, hopefully it should give you an accurate running-sum and balance figure at the end: 8. And here's the view that ties it all together: Used like so: I hope this helps anyone else wanting to do accurate bookkeeping with PayPal Transaction History files!"